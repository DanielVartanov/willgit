#!/usr/bin/env ruby

## git-wtf: display the state of your repository in a readable and easy-to-scan
## format. git-wtf tries to ease the task of dealing with many git branches.
## It's also useful for getting a summary of how tracking branches relate to a
## remote server.
##
## git-wtf is mainly useful in the case where you have one local repo and one
## remote repo, and you're interested in the relationship between the two.
##
## git-wtf shows you:
## - How your branch relates to the remote repo, if it's a tracking branch.
## - How your branch relates to non-feature (what I've been calling "version")
##   branches, if it's a feature branch.
## - How your branch relates to the feature branches, if it's a version branch.
##
## For each of these relationships, git-wtf displays the commits pending on
## either side, if any. It displays checkboxes along the side for easy scanning
## of merged/non-merged branches.
##
## OUTPUT KEY
##
## [] means the branch exists locally and remotely
## () means the branch only exists locally
## {} means it only exists on a remote repo
##
## x means the merge occurs both locally and remotely
## ~ means the merge occurs only locally
##   (space) means the branch isn't merged in
##
## It's possible for merges to occur remotely and not locally, of course, but
## that's a less common case and git-wtf currently doesn't display anything
## special for it.
##
## USAGE
##
## git wtf [branch+] [-l|--long] [-a|--all] [-A|--all-commits] [-s|--short]
##
## git-wtf is best used after a 'git fetch' and before a 'git push' or a 'git
## merge'.
##
## If [branch] is not specified, git-wtf will use the current branch.  With
## --long, you'll see author info and date for each commit. With --all-commits,
## you'll see all commits, not just the first 5; with --short, you'll see none.
## With --dump-config, git-wtf will print out its current configuration in YAML
## format and exit. With --all, you'll see all feature branches across all
## remote repos, not just those from origin.
##
## git-wtf uses some heuristics to determine which branches are version
## branches, and which are feature branches. (Specifically, it assumes the
## version branches are named "master", "next" and "edge".) If it guesses
## incorrectly, you will have to create a .git-wtfrc file.
##
## git-wtf looks for a .git-wtfrc file starting in the current directory, and
## recursively up to the root. The config file is a YAML file that specifies
## the version branches, any branches to ignore, and the max number of commits
## to display when --all-commits isn't used. To start building a configuration
## file, run "git-wtf --dump-config > .git-wtfrc" and edit it.
##
## IMPORTANT NOTE: all local branches referenced in .git-wtfrc must be prefixed
## with heads/, e.g. "heads/master". Remote branches must be of the form
## remotes/<remote>/<branch>.
##
## git-wtf Copyright 2008 William Morgan <wmorgan-git-wt-add@masanjin.net>.
## This program is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
## more details.
##
## You can find the GNU General Public License at: http://www.gnu.org/licenses/

require 'yaml'
CONFIG_FN = ".git-wtfrc"

class Numeric; def pluralize s; "#{to_s} #{s}" + (self != 1 ? "s" : "") end end

$long = ARGV.delete("--long") || ARGV.delete("-l")
$short = ARGV.delete("--short") || ARGV.delete("-s")
$all = ARGV.delete("--all") || ARGV.delete("-a")
$all_commits = ARGV.delete("--all-commits") || ARGV.delete("-A")
$dump_config = ARGV.delete("--dump-config")

## find config file
$config = { "versions" => %w(heads/master heads/next heads/edge), "ignore" => [], "max_commits" => 5 }.merge begin
  p = File.expand_path "."
  fn = while true
    fn = File.join p, CONFIG_FN
    break fn if File.exist? fn
    pp = File.expand_path File.join(p, "..")
    break if p == pp
    p = pp
  end

  (fn && YAML::load_file(fn)) || {} # YAML turns empty files into false
end

if $dump_config
  puts $config.to_yaml
  exit(0)
end

## the set of commits in 'to' that aren't in 'from'.
## if empty, 'to' has been merged into 'from'.
def commits_between from, to
  if $long
    `git log --pretty=format:"- %s [%h] (%ae; %ar)" #{from}..#{to}`
  else
    `git log --pretty=format:"- %s [%h]" #{from}..#{to}`
  end.split(/[\r\n]+/)
end

def show_commits commits, prefix="    "
  if commits.empty?
    puts "#{prefix} none"
  else
    max = $all_commits ? commits.size : $config["max_commits"]
    max -= 1 if max == commits.size - 1 # never show "and 1 more"
    commits[0 ... max].each { |c| puts "#{prefix}#{c}" }
    puts "#{prefix}... and #{commits.size - max} more." if commits.size > max
  end
end

def ahead_behind_string ahead, behind
  [ahead.empty? ? nil : "#{ahead.size.pluralize 'commit'} ahead",
   behind.empty? ? nil : "#{behind.size.pluralize 'commit'} behind"].
   compact.join("; ")
end

def widget merged_in, remote_only=false, local_only=false, local_only_merge=false
  left, right = case
    when remote_only; %w({ })
    when local_only; %w{( )}
    else %w([ ])
  end
  middle = case
    when merged_in && local_only_merge; "~"
    when merged_in; "x"
    else " "
  end
  print left, middle, right
end

def show b, all_branches
  have_both = b[:local_branch] && b[:remote_branch]

  pushc, pullc, oosync = if have_both
    [x = commits_between(b[:remote_branch], b[:local_branch]),
     y = commits_between(b[:local_branch], b[:remote_branch]),
     !x.empty? && !y.empty?]
  end

  if b[:local_branch]
    puts "Local branch: #{b[:local_branch]}"

    if have_both
      if pushc.empty?
        puts "#{widget true} in sync with remote"
      else
        action = oosync ? "push after rebase / merge" : "push"
        puts "#{widget false} NOT in sync with remote (needs #{action})"
        show_commits pushc unless $short
      end
    end
  end

  if b[:remote_branch]
    puts "Remote branch: #{b[:remote_branch]} (#{b[:remote_url]})"

    if have_both
      if pullc.empty?
        puts "#{widget true} in sync with local"
      else
        action = pushc.empty? ? "merge" : "rebase / merge"
        puts "#{widget false} NOT in sync with local (needs #{action})"
        show_commits pullc unless $short
      end
    end
  end

  vbs, fbs = all_branches.partition { |name, br| $config["versions"].include? br[:local_branch] }
  if $config["versions"].include? b[:local_branch]
    puts "\nFeature branches:" unless fbs.empty?
    fbs.each do |name, br|
      next if $config["ignore"].member?(br[:local_branch]) || $config["ignore"].member?(br[:remote_branch])
      local_only = br[:remote_branch].nil?
      remote_only = br[:local_branch].nil?
      ## for remote_only branches, we'll compute wrt the remote branch head. otherwise, we'll
      ## use the local branch head.
      head = remote_only ? br[:remote_branch] : br[:local_branch]

      remote_ahead = b[:remote_branch] ? commits_between(b[:remote_branch], head) : []
      local_ahead = b[:local_branch] ? commits_between(b[:local_branch], head) : []

      if local_ahead.empty? && remote_ahead.empty?
        puts "#{widget true, remote_only, local_only} #{br[:name]} is merged in"
      elsif local_ahead.empty?
        puts "#{widget true, remote_only, local_only, true} #{br[:name]} merged in (only locally)"
      else
        behind = commits_between head, (br[:local_branch] || br[:remote_branch])
        ahead = remote_only ? remote_ahead : local_ahead
        puts "#{widget false, remote_only, local_only} #{br[:name]} is NOT merged in (#{ahead_behind_string ahead, behind})"
        show_commits ahead unless $short
      end
    end
  else
    puts "\nVersion branches:" unless vbs.empty? # unlikely
    vbs.each do |v, br|
      local_only = br[:remote_branch].nil?
      ahead = commits_between v, (b[:local_branch] || b[:remote_branch])
      if ahead.empty?
        puts "#{widget true, local_only} merged into #{v}"
      else
        #behind = commits_between b[:local_branch], v
        puts "#{widget false, local_only} NOT merged into #{v} (#{ahead.size.pluralize 'commit'} ahead)"
        show_commits ahead unless $short
      end
    end
  end

  puts "\nWARNING: local and remote branches have diverged. A merge will occur unless you rebase." if oosync
end

## first, index registered remotes
remotes = `git config --get-regexp ^remote\.\*\.url`.inject({}) do |hash, l|
  l =~ /^remote\.(.+?)\.url (.+)$/ or next hash
  hash[$1] ||= $2
  hash
end

## next, index followed branches
branches = `git config --get-regexp ^branch\.`.inject({}) do |hash, l|
  case l
  when /branch\.(.*?)\.remote (.+)/
    name, remote = $1, $2
    next if remote == '.'

    hash[name] ||= {}
    hash[name].merge! :remote => remote, :remote_url => remotes[remote]
  when /branch\.(.*?)\.merge ((refs\/)?heads\/)?(.+)/
    name, remote_branch = $1, $4
    hash[name] ||= {}
    hash[name].merge! :remote_mergepoint => remote_branch
  end
  hash
end

## finally, index all branches
`git show-ref`.each do |l|
  sha1, ref = l.chomp.split " refs/"

  if ref =~ /^heads\/(.+)$/ # local branch
    name = $1
    next if name == "HEAD"
    branches[name] ||= {}
    branches[name].merge! :name => name, :local_branch => ref
  elsif ref =~ /^remotes\/(.+?)\/(.+)$/ # remote branch
    remote, name = $1, $2
    next if name == "HEAD"
    next unless $all || remote == "origin"

    branch = name
    if branches[name] && branches[name][:remote] == remote
      # nothing
    else
      name = "#{remote}/#{branch}"
    end

    branches[name] ||= {}
    branches[name].merge! :name => name, :remote => remote, :remote_branch => "#{remote}/#{branch}", :remote_url => remotes[remote]
  end
end

branches.each { |k, b| b[:remote_branch] = "#{b[:remote]}/#{b[:remote_mergepoint]}" if b[:remote] && b[:remote_mergepoint] }

show_dirty = ARGV.empty?
targets = if ARGV.empty?
  [`git symbolic-ref HEAD`.chomp.sub(/^refs\/heads\//, "")]
else
  ARGV.map { |x| x.sub(/^heads\//, "") }
end.map { |t| branches[t] or abort "Error: can't find branch #{t.inspect}." }

targets.each { |t| show t, branches }

modified = show_dirty && `git ls-files -m` != ""
uncommitted = show_dirty &&  `git diff-index --cached HEAD` != ""

puts if modified || uncommitted
puts "NOTE: working directory contains modified files" if modified
puts "NOTE: staging area contains staged but uncommitted files" if uncommitted

# the end!
